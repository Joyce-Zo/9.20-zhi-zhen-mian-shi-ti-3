#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

int main() 
{
	int a[4] = { 1,2,3,4 };
 a 存在内存里：|01 00 00 00|02 00 00 00|03 00 00 00|04 00 00 00| - 小端存储
																  ptr
	int* ptr1 = (int*)(&a + 1); 
	int* ptr2 = (int*)((int)a + 1);
		 0x00 00 00 01 +1=0x00 00 00 02,存储在第二个字节，再转化为int*
			  ptr2 16进制 - |00 00 00 02|，打印 |0x02 00 00 00|
	printf("%x\n%x\n", ptr1[-1], *ptr2);
					 ptr1[-1] = *(ptr+(-1)) = *(ptr-1) = 04 00 00 00
	return 0;
}

#include <stdio.h>
int main()
{
	int a[3][2] = { (0,1),(2,3),(4,5) };
				(x,y)，逗号表达式，结尾是后面的y
				{ 1 , 3 , 5 } 所以数组a三行2列，第一行是1，3，第二行是5，0，第三行0，0
	int* p;
	p = a[0];	// a[0]是首元素地址，是 1 的地址存入p中
	printf("%d", p[0]);//  打印出p[0] = *(p+0)，首元素地址解引用，就是1
	return 0;
}

int main()
{
	int a[5][5];
	 a数组 5*5
	int(*p)[4];
	 p是指向4个整型元素数组的指针 - 数组指针
	p = (int(*)[4]) a;
			a强行赋给p，a - 首元素地址
	 p+1 - 指向第1行第5个元素，+2 - 指向第2行第4个元素
	 p+3 - 指向第3行第3个元素，+4 - 指向第4行第2个元素
	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
	   &a[4][2] - 第5行第3个元素的地址
	  p[4][2] = *(*(p+4)+2),解引用后访问4个字节，从p+4开始向后4个字节
											再+2，p+4开始向后第2个字节，然后取此地址
			p - p = 指针之间元素个数 p-a = -4,%d = -4,%p = fffffffc
	   -4 10000000000000000000000000000100 原  - 打印%d
			11111111111111111111111111111011 反
			1111 1111 1111 1111 1111 1111 1111 1100 补码 - 打印地址
	        F   F    F    F	 F   F     F     C
	return 0;
}

int main()
{
	int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
	int* ptr1 = (int*)(&aa + 1);
				& 整个数组的地址，+1指向10后面，解引用-1访问元素10
	int* ptr2 = (int*)(*(aa + 1));
				&aa即数组第一行的地址，+1则是第二行首元素地址，即6,-1访问元素5
	printf("%d,%d", *(ptr1 - 1), *(ptr2 - 1));
	return 0;
}